---
title: "理解 Assassyn 中的端口写入"
format:
  html:
    toc: true
    toc-depth: 3
    mermaid:
      theme: default
      themeVariables:
        clusterBkg: "#f8fafc"
        clusterBorder: "#cbd5e1"
        primaryColor: "#ffffff"
        primaryTextColor: "#0f172a"
        lineColor: "#475569"

---

# 教程:理解 Assassyn 中的端口写入

> **作者:** Yao Wentao 
> 
> **日期:** 2025.10.15
>

## 1. 引言

在之前的教程中,我们学习了使用 `async_called()` 进行模块间通信。实际上,`async_called()` 底层使用**端口写入**(`.push()` 操作)来向模块端口发送数据。本教程将深入探讨端口写入,让您能够更精细地控制模块间通信。

**学习目标:**

* 理解 `async_called()` 和 `.push()` 之间的关系
* 学习如何使用 `.push()` 显式写入端口数据
* 掌握基于 FIFO 的模块间通信机制
* 理解 FIFO 深度配置和背压机制

---

## 2. 端口基础回顾

### 2.1 什么是端口?

**端口(Port)** 是 Assassyn 模块中的类型化通信接口。每个端口包含:
- **数据类型**(例如 `UInt(32)`, `Int(64)`)
- 用于存储数据的 **FIFO 缓冲区**
- 操作方法:`push()`(写入)、`pop()`(读取)、`peek()`(读取但不消耗)、`valid()`(检查是否有数据)

### 2.2 端口操作概览

```{mermaid}
%%| fig-width: 8
flowchart LR
  subgraph Producer["生产者模块"]
    P1["计算值"]
    P2["port.push(value)"]
  end

  subgraph FIFO["端口FIFO缓冲区"]
    F1["队列存储"]
  end

  subgraph Consumer["消费者模块"]
    C1["port.valid()"]
    C2["port.pop()"]
    C3["处理值"]
  end

  P1 --> P2
  P2 -->|写入| F1
  F1 -->|读取| C1
  C1 --> C2
  C2 --> C3

  style FIFO fill:#fff3e0
  style Producer fill:#e3f2fd
  style Consumer fill:#e8f5e9
```

---

## 3. 端口写入基础

### 3.1 `.push()` 操作

`.push()` 方法将数据写入端口的 FIFO 缓冲区:

```python
# port.push(value) - 将值写入端口
my_module.my_port.push(some_value)
```

**关键特性:**
- **非阻塞写入:**数据被放入 FIFO 队列
- **一周期延迟:**消费者在下一周期读取数据
- **FIFO 缓冲:**可以排队多个值(取决于 FIFO 深度)

### 3.2 `async_called()` 如何使用 `.push()`

当你写:
```python
adder.async_called(a=value1, b=value2)
```

Assassyn 内部会创建:
```python
adder.a.push(value1)
adder.b.push(value2)
# 然后触发模块执行
```

这就解释了为什么 `async_called()` 需要提供**所有端口**的值!

---

## 4. 环境设置

为示例设置环境:

```{python}
#| code-fold: false

import warnings
warnings.filterwarnings("ignore")

import sys
import os

# Set ASSASSYN_HOME environment variable before importing assassyn
assassyn_home = os.path.abspath(os.path.join(os.path.dirname("04_port_writing_zh.qmd"), '..'))
os.environ['ASSASSYN_HOME'] = assassyn_home

lib_path = os.path.join(assassyn_home, 'python')
sys.path.insert(0, lib_path)

from function_t import run_quietly
from assassyn.frontend import *
from assassyn.backend import elaborate
from assassyn import utils
import assassyn

print("✅ 环境设置完成")
```

---

## 5. 实践示例:生产者-消费者模式

### 5.1 系统架构

```{mermaid}
%%| fig-width: 10
flowchart TD
  subgraph Driver["Driver生产者"]
    D1["生成计数器"]
    D2["推送到Producer"]
  end

  subgraph Producer["Producer模块"]
    P1["通过端口接收数据"]
    P2["处理: data * 2"]
    P3["推送到Consumer"]
  end

  subgraph Consumer["Consumer模块"]
    C1["通过端口接收"]
    C2["处理: data + 100"]
    C3["记录结果"]
  end

  D1 --> D2
  D2 -->|async_called| P1
  P1 --> P2
  P2 --> P3
  P3 -->|显式push| C1
  C1 --> C2
  C2 --> C3

  style Driver fill:#e3f2fd
  style Producer fill:#fff3e0
  style Consumer fill:#e8f5e9
```

### 5.2 模块定义

#### Consumer 模块

该模块有一个输入端口并处理接收到的数据:

```{python}
#| code-fold: false

class Consumer(Module):
    def __init__(self):
        super().__init__(
            ports={'data_in': Port(UInt(32))}
        )

    @module.combinational
    def build(self):
        # 从端口弹出数据
        data = self.pop_all_ports(True)

        # 处理:加 100
        result = data + UInt(32)(100)

        log("Consumer 接收: {}, 结果: {}", data, result)

print("✅ Consumer 模块已定义")
```

#### Producer 模块

该模块接收数据,处理后显式推送到消费者:

```{python}
#| code-fold: false

class Producer(Module):
    def __init__(self):
        super().__init__(
            ports={'data_in': Port(UInt(32))}
        )

    @module.combinational
    def build(self, consumer: Consumer):
        # 从上游接收数据
        data = self.pop_all_ports(True)

        # 处理:左移1位(相当于乘以2)，保持 UInt(32) 类型
        processed = data << UInt(32)(1)

        log("Producer 接收: {}, 发送: {}", data, processed)

        # 显式推送到消费者的端口
        consumer.data_in.push(processed)

print("✅ Producer 模块已定义")
```

**关键点:**注意 `Producer.build()` 如何显式调用 `consumer.data_in.push(processed)` 来发送数据到消费者的端口。这就是**显式端口写入**操作。

#### Driver 模块

驱动器生成数据并馈送给生产者:

```{python}
#| code-fold: false

class Driver(Module):
    def __init__(self):
        super().__init__(ports={})

    @module.combinational
    def build(self, producer: Producer):
        cnt = RegArray(UInt(32), 1)
        (cnt & self)[0] <= cnt[0] + UInt(32)(1)

        # 只发送前 10 个值
        cond = cnt[0] < UInt(32)(10)
        with Condition(cond):
            producer.async_called(data_in=cnt[0])

print("✅ Driver 模块已定义")
```

### 5.3 时序图

理解端口操作的时序:

```{mermaid}
%%| fig-width: 10
sequenceDiagram
  autonumber
  participant D as Driver
  participant P as Producer
  participant C as Consumer
  participant L as 日志输出

  Note over D: 周期N cnt=0
  D->>P: async_called data_in=0
  Note over P: FIFO接收0

  Note over D: 周期N+1 cnt=1
  Note over P: 执行 received=0
  P->>P: processed=0*2=0
  P->>L: log Producer接收0发送0
  P->>C: push 0
  D->>P: async_called data_in=1

  Note over D: 周期N+2 cnt=2
  Note over C: 执行 received=0
  C->>C: result=0+100=100
  C->>L: log Consumer接收0结果100
  Note over P: 执行 received=1
  P->>P: processed=1*2=2
  P->>L: log Producer接收1发送2
  P->>C: push 2

  Note over D,C: 流水线2周期延迟
```

---

## 6. 验证逻辑

定义一个函数来验证输出:

```{python}
def check_output(raw):
    producer_lines = []
    consumer_lines = []

    for line in raw.split('\n'):
        # 查找包含 "Producer 接收:" 的行
        if 'Producer' in line and '接收' in line:
            # 提取: Producer 接收: X, 发送: Y
            try:
                # 格式: @line:... [ProducerInstance] Producer 接收: X, 发送: Y
                if '发送:' in line:
                    parts = line.split('发送:')
                    if len(parts) == 2:
                        sent_val_str = parts[1].strip().rstrip(',')
                        sent_val = int(sent_val_str)
                        producer_lines.append(sent_val)
            except (ValueError, IndexError) as e:
                print(f"警告: 解析 Producer 行失败: {line}, 错误: {e}")

        # 查找包含 "Consumer 接收:" 的行
        elif 'Consumer' in line and '接收' in line:
            # 提取: Consumer 接收: X, 结果: Y
            try:
                # 格式: @line:... [ConsumerInstance] Consumer 接收: X, 结果: Y
                if '结果:' in line:
                    parts = line.split('结果:')
                    if len(parts) == 2:
                        result_val_str = parts[1].strip().rstrip(',')
                        result_val = int(result_val_str)
                        consumer_lines.append(result_val)
            except (ValueError, IndexError) as e:
                print(f"警告: 解析 Consumer 行失败: {line}, 错误: {e}")

    print(f"DEBUG: 找到 {len(producer_lines)} 个 Producer 输出")
    print(f"DEBUG: 找到 {len(consumer_lines)} 个 Consumer 输出")

    # 验证流水线: Consumer 接收 Producer 发送的内容
    if len(producer_lines) == 0:
        print("⚠️ 警告: 未找到 Producer 输出，可能是输出格式问题")
        return

    if len(consumer_lines) == 0:
        print("⚠️ 警告: 未找到 Consumer 输出，可能是输出格式问题")
        return

    # 验证: Consumer 结果 = Producer 发送 + 100
    for i in range(min(len(producer_lines), len(consumer_lines))):
        expected = producer_lines[i] + 100
        actual = consumer_lines[i]
        if actual != expected:
            print(f"❌ 位置 {i} 不匹配: 期望 {expected}, 实际 {actual}")
            return

    print(f"✅ 验证通过! Producer 发送了 {len(producer_lines)} 个值, Consumer 处理了 {len(consumer_lines)} 个值")

print("✅ 验证函数已定义")
```

---

## 7. 构建和仿真

现在让我们构建系统并运行仿真:

```{python}
#| output-fold: true

print("开始构建和仿真...")

# 1. 构建系统
sys = SysBuilder('port_writing')
with sys:
    # 实例化模块
    consumer = Consumer()
    consumer.build()

    producer = Producer()
    producer.build(consumer)

    driver = Driver()
    driver.build(producer)

print(sys)

# 2. 配置仿真参数
config = assassyn.backend.config(
    verilog=utils.has_verilator(),
    sim_threshold=50,
    idle_threshold=50,
    random=True
)

# 3. 生成仿真器
def generate_simulator():
    return elaborate(sys, **config)

(simulator_path, verilator_path), _, _ = run_quietly(generate_simulator)
print("✅ 仿真器生成完成")

# 4. 运行仿真器
def run_sim():
    return utils.run_simulator(simulator_path)

raw, stdout, stderr = run_quietly(run_sim)

# 检查 raw 是否为 None (表示执行过程中出错)
if raw is None or not isinstance(raw, str):
    print("⚠️ 错误: 仿真器执行失败")
    if stderr:
        print("错误输出:")
        print(stderr)
    if stdout:
        print("标准输出:")
        print(stdout)
    raise RuntimeError(f"仿真器失败: {stderr}")

print("\n=== 仿真器输出(前 10 对)===")
count = 0
print("DEBUG: 开始解析输出...")
print(f"DEBUG: 输出总长度: {len(raw)} 字符")
print("DEBUG: 前500字符:")
print(raw[:500])
print("\nDEBUG: 查找包含 'Producer' 或 'Consumer' 的行...")
for line in raw.split('\n'):
    if 'Producer' in line or 'Consumer' in line:
        print(line.strip())
        if 'Consumer' in line:
            count += 1
            if count >= 10:
                break

# 验证输出
check_output(raw)

# 如果有 Verilator,也运行 Verilator 验证
if verilator_path:
    print("\n=== Verilator 验证 ===")

    def run_verilator():
        return utils.run_verilator(verilator_path)

    raw_verilator, stdout_v, stderr_v = run_quietly(run_verilator)

    # 检查 raw_verilator 是否为 None
    if raw_verilator is None or not isinstance(raw_verilator, str):
        print("⚠️ 错误: Verilator 执行失败")
        if stderr_v:
            print("错误输出:")
            print(stderr_v)
        if stdout_v:
            print("标准输出:")
            print(stdout_v)
        raise RuntimeError(f"Verilator 失败: {stderr_v}")

    # 验证 Verilator 的输出
    check_output(raw_verilator)
else:
    print("⚠️ Verilator 未安装,跳过 Verilator 验证")
```

---

## 8. 对比:`async_called()` vs 显式 `.push()`

| 特性 | `async_called()` | 显式 `.push()` |
|---------|------------------|-------------------|
| **用法** | 高级 API | 低级 API |
| **端口** | 必须提供所有端口 | 可以推送到单个端口 |
| **便利性** | 更方便 | 更灵活 |
| **模块激活** | 自动触发模块 | 手动控制时序 |
| **典型用例** | 标准模块间调用 | 复杂通信模式 |

**何时使用 `.push()`:**
- 需要细粒度控制端口写入
- 想要有条件地推送到某些端口
- 构建自定义通信模式
- 实现专用协议

**何时使用 `async_called()`:**
- 标准模块到模块通信
- 所有端口都需要值
- 更简单、更清晰的代码

---

## 9. 关键要点

1. **`.push()` 是写入端口的基本操作**
2. **`async_called()` 内部对所有端口使用 `.push()`**
3. **FIFO 缓冲区**实现异步、流水线通信
4. **流水线阶段**通过基于端口的通信创建
5. **显式端口写入**在需要时提供细粒度控制
