---
title: "理解 Assassyn 中的跨阶段引用：Bind 机制"
format:
  html:
    toc: true
    toc-depth: 3
    mermaid:
      theme: default
      themeVariables:
        clusterBkg: "#f8fafc"
        clusterBorder: "#cbd5e1"
        primaryColor: "#ffffff"
        primaryTextColor: "#0f172a"
        lineColor: "#475569"

---

# 教程：理解跨阶段引用 - Bind 机制

> **作者：** Yao Wentao
> **日期：** 2025.10.24
>

## 1. 什么是 Bind？

### 1.1 Python 类比

想象你有一个 Python 函数需要多个参数，但这些参数来自不同的地方、不同的时间：

```python
# 普通的 Python 函数
def subtract(a, b):
    return a - b

# 使用 functools.partial 部分绑定参数
import functools
partial_sub = functools.partial(subtract, a=10)  # 先绑定 a

# 稍后，当 b 可用时，完成调用
result = partial_sub(b=3)  # 结果: 10 - 3 = 7
```

### 1.2 Assassyn 中的 Bind

在 Assassyn 中，**Bind** 实现同样的思想，但用于硬件模块的跨流水线阶段调用：

```python
# 阶段 1: 部分绑定参数
bound = module.bind(arg_a=value1)

# 阶段 2: 完成绑定并调用
AsyncCall(bound.bind(arg_b=value2))
```

**Bind 解决的问题：** <br>
- **分流（Diverge）**：一个源向多个目标发送数据 <br>
- **汇聚（Converge）**：多个源的数据最终汇聚到同一个目标 <br>
- **时序解耦**：不同阶段的数据在不同时间到达 <br>

---

## 2. 数据分流和汇聚模式

```{mermaid}
%%| fig-width: 10
flowchart TD
  subgraph Driver[驱动阶段]
    D1[生成数据]
  end

  subgraph LHS[左路径阶段]
    L1[处理左侧数据]
    L2["bind(sub_a=data)"]
  end

  subgraph RHS[右路径阶段]
    R1[处理右侧数据]
    R2["async_called(sub_b=data)"]
  end

  subgraph Sub[减法器阶段]
    S1[接收 a 和 b]
    S2[计算 a - b]
  end

  D1 -- 数据 --> L1
  D1 -- 数据 --> R1
  L1 --> L2
  R1 --> R2
  L2 -- "Bind(sub_a)" --> R2
  R2 -- "完成绑定" --> S1
  S1 --> S2

  style Driver fill:#e3f2fd
  style LHS fill:#fff3e0
  style RHS fill:#ffe0e0
  style Sub fill:#e8f5e9
```

**数据流说明：** <br>
- Driver 分流数据到 LHS 和 RHS 两条路径 <br>
- LHS 绑定 `sub_a` 参数并返回 Bind 对象 <br>
- RHS 接收 Bind，添加 `sub_b`，创建完整的AsyncCall <br>
- Sub 模块从不同阶段汇聚两个参数并执行

---

## 3. 环境设置

```{python}
#| code-fold: false

import warnings
warnings.filterwarnings("ignore")

import sys
import os

assassyn_home = os.path.abspath(os.path.join(os.path.dirname("06_bind_zh.qmd"), '..'))
os.environ['ASSASSYN_HOME'] = assassyn_home
lib_path = os.path.join(assassyn_home, 'python')
sys.path.insert(0, lib_path)

from function_t import run_quietly
from assassyn.frontend import *
from assassyn.backend import elaborate
from assassyn import utils
import assassyn

print("✅ 环境设置完成")
```

---

## 4. 完整示例：分流-汇聚系统

### 4.1 定义所有模块

```{python}
#| code-fold: false

# Subtractor: 接收两个参数并执行减法
class Subtractor(Module):
    def __init__(self):
        super().__init__(ports={'sub_a': Port(Int(32)), 'sub_b': Port(Int(32))})

    @module.combinational
    def build(self):
        a, b = self.pop_all_ports(False)
        c = a - b
        log("减法器: {} - {} = {}", a, b, c)

# LeftPath: 创建部分 Bind
class LeftPath(Module):
    def __init__(self):
        super().__init__(ports={'lhs_a': Port(Int(32))})

    @module.combinational
    def build(self, sub: Subtractor):
        lhs_a = self.pop_all_ports(True)
        # 只绑定 sub_a，返回部分 Bind
        return sub.bind(sub_a=lhs_a)

# RightPath: 完成 Bind 并创建 AsyncCall
class RightPath(Module):
    def __init__(self):
        super().__init__(ports={'rhs_b': Port(Int(32))})

    @module.combinational
    def build(self, bound_sub):
        rhs_b = self.pop_all_ports(True)
        # 添加 sub_b 并创建 AsyncCall
        call = bound_sub.async_called(sub_b=rhs_b)
        call.bind.set_fifo_depth(sub_a=2, sub_b=2)

# Driver: 数据分流
class Driver(Module):
    def __init__(self):
        super().__init__(ports={})

    @module.combinational
    def build(self, lhs: LeftPath, rhs: RightPath):
        cnt = RegArray(Int(32), 1)
        (cnt & self)[0] <= cnt[0] + Int(32)(1)

        v = cnt[0] * cnt[0]
        call_lhs = lhs.async_called(lhs_a=v[0:31].bitcast(Int(32)))
        call_lhs.bind.set_fifo_depth(lhs_a=2)

        call_rhs = rhs.async_called(rhs_b=cnt[0])
        call_rhs.bind.set_fifo_depth(rhs_b=2)

print("✅ 所有模块已定义")
```

---

## 5. 构建和仿真

### 5.1 系统构建

```{python}
#| code-fold: false

print("正在构建系统...")

sys = SysBuilder('bind_demo')
with sys:
    # 创建减法器
    sub = Subtractor()
    sub.build()

    # 创建左路径并获取部分 Bind
    lhs = LeftPath()
    bound_sub = lhs.build(sub)

    # 创建右路径，传递 Bind
    rhs = RightPath()
    rhs.build(bound_sub)

    # 创建驱动器
    driver = Driver()
    driver.build(lhs, rhs)

print(sys)
```

### 5.2 运行仿真

```{python}
#| output-fold: true

# 配置仿真参数
config = assassyn.backend.config(
    verilog=utils.has_verilator(),
    sim_threshold=100,
    idle_threshold=100,
    random=False
)

# 生成仿真器
def generate_simulator():
    return elaborate(sys, **config)

(simulator_path, verilator_path), _, _ = run_quietly(generate_simulator)
print("✅ 仿真器生成完成")

# 运行仿真器
def run_sim():
    return utils.run_simulator(simulator_path)

raw, stdout, stderr = run_quietly(run_sim)

if raw is None or not isinstance(raw, str):
    print("⚠️ 错误：仿真器执行失败")
    if stderr:
        print("错误输出：")
        print(stderr)
    raise RuntimeError(f"仿真器失败: {stderr}")

print("\n=== 仿真器输出（前 10 个结果）===")
count = 0
for line in raw.split('\n'):
    if '减法器' in line:
        print(line.strip())
        count += 1
        if count >= 10:
            break

# 验证结果
def check_output(raw):
    cnt = 0
    for line in raw.split('\n'):
        if '减法器' in line:
            line_toks = line.split()
            c = line_toks[-1]
            a = line_toks[-3]
            b = line_toks[-5]
            if int(a) - int(b) == int(c):
                cnt += 1
    print(f"\n✅ 验证通过！正确处理了 {cnt} 个减法操作")
    return cnt

result_count = check_output(raw)
```

---

## 6. 关键概念总结

### 6.1 Bind vs async_called()

| 特性 | `.bind()` | `.async_called()` |
|------|-----------|-------------------|
| **返回值** | `Bind` 对象 | `AsyncCall` 对象 |
| **执行** | 不执行，只绑定参数 | 触发模块执行 |
| **完整性** | 可以是部分的 | 必须绑定所有端口 |
| **用例** | 跨阶段参数传递 | 直接调用 |

**Python 类比：**
```python
# async_called() 就像直接调用函数
result = subtract(a=10, b=3)

# bind() 就像 functools.partial
partial_sub = functools.partial(subtract, a=10)
result = partial_sub(b=3)
```

### 6.2 常见模式

**模式 1：渐进式绑定** - 跨多个阶段逐步构建参数
```python
bound1 = module.bind(param1=value1)      # 阶段 1
bound2 = bound1.bind(param2=value2)      # 阶段 2
AsyncCall(bound2.bind(param3=value3))    # 阶段 3: 完成
```

**模式 2：分流-汇聚** - 数据从一个源分发，然后汇聚到同一目标
```python
# 驱动器分流数据
lhs.async_called(data=value)
rhs.async_called(data=value)
# LHS 和 RHS 处理后汇聚到同一个模块
```

---

## 7. 延伸阅读

- `python/assassyn/ir/expr/call.md` - Bind 和 AsyncCall IR 节点详细说明
- `docs/design/lang/dsl.md` - DSL 设计，包括数据分流模式
- `docs/design/arch/arch.md` - 跨阶段组合通信架构
