---
title: "Assassyn 模块间异步调用教程"
format:
  html:
    toc: true
    toc-depth: 2
    mermaid:
      theme: default
      themeVariables:
        clusterBkg: "#f8fafc"
        clusterBorder: "#cbd5e1"
        primaryColor: "#ffffff"
        primaryTextColor: "#0f172a"
        lineColor: "#475569"

---

# 教程：使用 assassyn 实现模块间异步调用

> **作者：** Yao Wentao
> **日期：** 2025.10.3
>

## 简介

欢迎来到本教程！在这里，我们将学习如何使用硬件描述库 `assassyn` 来实现模块间的异步调用。

**学习目标:**

* 了解 `assassyn` 中的模块通信机制。
* 学习如何定义带有端口（Port）的模块。
* 掌握异步调用（`async_called`）的使用方法。
* 掌握`SysBuilder`的编写。
* 通过一个加法器示例，实践模块间的交互。

---

# 2. 核心代码讲解

我们的项目由四部分组成：加法器模块定义、驱动器模块定义、结果验证函数和主执行函数。

## 2.0.1 系统架构概览

在开始详细讲解之前，让我们先通过图表理解整个系统的架构：

```{mermaid}
classDiagram
  class Module{
    +async_called(...)
    +@module.combinational build(...)
  }

  class Driver{
    +build(adder: Adder)
  }

  class Adder{
    +build()
  }

  Module <|-- Driver
  Module <|-- Adder

  Driver --> Adder: async_called
```

这个类图展示了：<br>
1. **Module 基类**：所有模块的基础类，提供端口管理和异步调用机制<br>
2. **Driver 模块**：主动调用者，使用计数器驱动整个系统<br>
3. **Adder 模块**：被动接收者，接收输入端口数据并执行加法 <br>
4. **调用关系**：Driver 通过 `async_called` 方法调用 Adder

## 2.0 环境基本配置

让我们首先设置基本环境：
```{python}
#| code-fold: false

import warnings
warnings.filterwarnings("ignore")

import sys
import os
import io
import contextlib
from typing import Tuple, Optional

lib_path = os.path.abspath(os.path.join(os.path.dirname("async_call.qmd"), '../python/'))
sys.path.append(lib_path)
from function_t import run_quietly

from assassyn.frontend import *
from assassyn.backend import elaborate
from assassyn import utils
import assassyn

print("✅ 环境设置完成")
```

## 2.1 验证逻辑 (`check_raw`)

现在，我们定义一个验证函数来检查加法器的输出是否符合预期：

```{python}
def check_raw(raw):
    cnt = 0
    for i in raw.split('\n'):
        if 'Adder:' in i:
            line_toks = i.split()
            c = line_toks[-1]
            a = line_toks[-3]
            b = line_toks[-5]
            assert int(a) + int(b) == int(c), f"加法错误: {a} + {b} != {c}"
            cnt += 1
    assert cnt == 100, f'预期运行 100 次，实际运行了 {cnt} 次'
    print(f"✅ 验证通过！加法器正确执行了 {cnt} 次计算")

print("✅ 验证函数定义完成")
```

这个验证函数会：

1.  解析模拟器的输出日志
2.  提取每次加法运算的输入和输出
3.  验证 a + b = c 是否成立
4.  确保总共执行了100次调用

## 2.2 加法器模块定义 (`Adder`)

首先，我们定义一个简单的加法器模块。这个模块接收两个32位整数输入，并计算它们的和。<br>

`Adder` 模块的特点：<br>
1. 它有输入端口（ports），可以接收来自其他模块的数据<br>
2. 它被动地等待其他模块调用<br>
3. 它执行简单的加法运算并打印结果<br>

```{python}
#| code-fold: false
class Adder(Module):
    def __init__(self):
        super().__init__(
            ports={
                'a': Port(Int(32)),
                'b': Port(Int(32)),
            },
        )

    @module.combinational
    def build(self):
        a, b = self.pop_all_ports(True)
        c = a + b
        log("Adder: {} + {} = {}", a, b, c)

print("✅ 加法器模块定义完成")
```

  * `ports={'a': Port(Int(32)), 'b': Port(Int(32))}`: 定义了模块的输入端口。
  * `Port`类是不区分输入和输出端口的，
  * `pop_all_ports(True)`: 获取所有端口的值，参数 `True` 表示按照端口定义的顺序返回。

## 2.3 驱动器模块定义 (`Driver`)

接下来，我们定义驱动器模块。这个模块负责主动调用加法器模块。<br>

```{python}
#| code-fold: false
class Driver(Module):
    def __init__(self):
        super().__init__(ports={})

    @module.combinational
    def build(self, adder: Adder):
        cnt = RegArray(Int(32), 1)
        (cnt & self)[0] <= cnt[0] + Int(32)(1)
        cond = cnt[0] < Int(32)(100)
        with Condition(cond):
            adder.async_called(a = cnt[0], b = cnt[0])

print("✅ 驱动器模块定义完成")
```

我们可以看到，这个模块：<br>
1. 创建了一个32位的计数器 `cnt` <br>
2. 每个周期将计数器加1 <br>
3. 检查计数器是否小于100 <br>
4. 如果条件满足，就异步调用加法器模块 <br>
5. 经过这个`async_called`调用，Driver和adder模块被划分为两级流水线


### 2.3.1 异步调用 (`async_called`)

  * `adder.async_called(a = cnt[0], b = cnt[0])`: 这是异步调用的核心语法。
  * 异步调用的特点：
    - 被调用的模块（Adder）会在**下一个周期**执行Driver模块这一个周期传递的参数
    - 调用时需要为所有端口提供值
  * 在这个例子中，我们用计数器的当前值作为加法器的两个输入，其log出来的结果总是会晚一个时钟周期，因为Adder模块的运行总是晚一个时钟周期

#### 异步调用时序详解

为了更好地理解异步调用的时序关系，让我们通过时序图来观察 Driver 和 Adder 在不同时钟周期的行为：

```{mermaid}
sequenceDiagram
  autonumber
  participant Driver as "Driver(驱动模块)"
  participant Adder as "Adder(加法器模块)"
  participant Log as "日志输出"

  Note over Driver: Cycle N, cnt = 0
  Driver->>Adder: async_called(a=0, b=0)
  Note over Adder: 收到调用请求,数据暂存到端口

  Note over Driver: Cycle N+1, cnt = 1
  Note over Adder: 执行 Cycle N 的计算
  Adder->>Log: log("0 + 0 = 0")
  Driver->>Adder: async_called(a=1, b=1)

  Note over Driver: Cycle N+2, cnt = 2
  Note over Adder: 执行 Cycle N+1 的计算
  Adder->>Log: log("1 + 1 = 2")
  Driver->>Adder: async_called(a=2, b=2)

  Note over Driver,Adder: 异步调用特点:Adder 的执行总是滞后 Driver 一个周期
```

**关键观察点：** <br>
1. **周期 N**：Driver 发送 `async_called(a=0, b=0)`，Adder 接收并暂存数据 <br>
2. **周期 N+1**：Adder 才真正执行周期 N 的计算，输出 "0 + 0 = 0"；同时 Driver 发送新的调用 `async_called(a=1, b=1)`<br>
3. **周期 N+2**：Adder 执行周期 N+1 的计算，输出 "1 + 1 = 2" <br>
4. **流水线行为**：这种一个周期的延迟形成了两级流水线结构 <br>
  


## 2.4 深入理解 SysBuilder

在开始系统构建之前，让我们深入理解 SysBuilder 的工作原理和使用方法。

### 2.4.1 SysBuilder 的作用

SysBuilder 是 assassyn 中的一个核心组件，它负责：

1.  系统组成：模块和arrays的基本组成单元
2.  驱动器的角色：类似程序的`main`函数
3.  执行机制：基于时钟周期的循环调用，即其在每个时钟上升沿调用
4.  构建功能：作为IR构建器，用于生成硬件描述

### 2.4.2 基本使用模式

```python
# 1. 创建系统构建器实例
sys = SysBuilder('system_name')

# 2. 使用上下文管理器进行系统构建
with sys:
    # 实例化模块
    module1 = Module1()
    module1.build()

    module2 = Module2()
    module2.build(module1)  # 模块间的连接

# 3. 系统配置和编译
config = {
    'verilog': True,       # 是否生成 Verilog
    'sim_threshold': 200,  # 仿真周期上限
    'idle_threshold': 200  # 空闲检测阈值
}

# 4. 生成仿真器
simulator_path, verilator_path = elaborate(sys, **config)
```

#### 系统构建流程图

```{mermaid}
flowchart TD
  A[创建 SysBuilder] --> B[进入上下文管理器]
  B --> C[实例化 Adder 模块]
  C --> D[调用 adder.build]
  D --> E[实例化 Driver 模块]
  E --> F["调用 driver.build,建立调用关系"]
  F --> G["退出上下文,完成系统构建"]
  G --> H[配置仿真参数]
  H --> I["调用 elaborate,生成 IR"]
  I --> J{生成 Verilog?}
  J -->|是| K[生成 Verilator 仿真器]
  J -->|否| L[仅生成 C++ 仿真器]
  K --> M[运行仿真验证]
  L --> M
  M --> N[输出日志并验证结果]

  style A fill:#e3f2fd
  style G fill:#e8f5e9
  style I fill:#fff3e0
  style M fill:#fce4ec
  style N fill:#f3e5f5
```

这个流程展示了从模块定义到最终运行验证的完整过程：<br>
1. **系统构建阶段**（蓝色）：创建 SysBuilder 实例 <br>
2. **模块连接阶段**（绿色）：实例化模块并建立调用关系 <br>
3. **IR 生成阶段**（橙色）：elaborate 将 Python 描述转换为中间表示 <br>
4. **仿真运行阶段**（粉色）：运行仿真器并验证结果 <br>

## 2.5 系统构建与仿真 (`test_async_call`)

这个函数将所有部分串联起来：

1.  用 `SysBuilder` 创建一个系统。
2.  实例化 `Adder` 和 `Driver` 模块。
3.  建立模块之间的调用关系。
4.  调用 `elaborate` 将我们的 Python 设计转换成RTL模型。
5.  运行仿真器和 Verilator 进行验证。

-----

# 3\. 完整代码与执行


现在，我们来构建系统、生成仿真器并运行验证。

```{python}
#| output-fold: true
print("开始构建和仿真...")

# 1. 构建系统
sys = SysBuilder('async_call')
with sys:
    adder = Adder()
    adder.build()

    driver = Driver()
    call = driver.build(adder)

print(sys)

# 2. 配置仿真参数
config = assassyn.backend.config(
        verilog=utils.has_verilator(),
        sim_threshold=200,
        idle_threshold=200,
        random=True)

# 3. 生成仿真器
def generate_simulator():
    return elaborate(sys, **config)

(simulator_path, verilator_path), _, _ = run_quietly(generate_simulator)
print("✅ 仿真器生成完成")

# 4. 运行仿真器
def run_sim():
    return utils.run_simulator(simulator_path)

raw, _, _ = run_quietly(run_sim)

print("\n=== 模拟器输出（前10次调用）===")
# 只显示前10次加法器的输出
count = 0
for line in raw.split('\n'):
    if 'Adder:' in line:
        print(line.strip())
        count += 1
        if count >= 10:
            break

# 验证输出
check_raw(raw)

# 如果有 Verilator，也运行 Verilator 验证
if verilator_path:
    print("\n=== Verilator 验证 ===")

    def run_verilator():
        return utils.run_verilator(verilator_path)

    raw_verilator, _, _ = run_quietly(run_verilator)

    # 显示 Verilator 的前10次输出
    count = 0
    for line in raw_verilator.split('\n'):
        if 'Adder:' in line:
            print(line.strip())
            count += 1
            if count >= 10:
                break

    # 验证 Verilator 的输出
    check_raw(raw_verilator)
else:
    print("⚠️ Verilator 未安装，跳过 Verilator 验证")
```

## 结果分析

从输出可以看到，我们的系统按预期工作：

* 加法器接收两个相同的输入（都是计数器的值），计算它们的和
* 总共执行了100次调用
* 并且加法器输出的结果总是会晚一个时钟周期。

这证明了我们的模块间通信和异步调用机制是正确的，并且async_call模块是一个具有两级流水线的模块

### 两级流水线结构可视化

```{mermaid}
flowchart LR
  subgraph Stage1[第一级流水线 - Driver]
    direction TB
    S1A[读取计数器 cnt]
    S1B[判断 cnt < 100]
    S1C[发送 async_called]
    S1D[更新计数器 cnt++]
    S1A --> S1B
    S1B --> S1C
    S1B --> S1D
  end

  subgraph Stage2[第二级流水线 - Adder]
    direction TB
    S2A[从端口读取 a, b]
    S2B[计算 c = a + b]
    S2C[输出日志]
    S2A --> S2B
    S2B --> S2C
  end

  Stage1 -->|数据通过端口寄存器,延迟一个周期| Stage2

  style Stage1 fill:#e3f2fd
  style Stage2 fill:#fff3e0
```

**流水线特性：** <br>
- **Stage 1 (Driver)**：在周期 N 完成计数、条件判断和异步调用 <br>
- **Stage 2 (Adder)**：在周期 N+1 处理周期 N 发送的数据<br>
- **寄存器分隔**：端口（Port）充当流水线寄存器，存储从 Driver 传递到 Adder 的数据<br>
- **吞吐率**：每个周期可以处理一次新的加法请求（在满载情况下）<br>
- **延迟**：从 Driver 发起调用到 Adder 输出结果，需要 1 个时钟周期<br>



