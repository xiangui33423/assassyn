# Architecture Template of Assassyn

This document describes the fundamental architectural patterns and execution model generated by Assassyn.
For memory system details, see [memory.md](./memory.md).
For Verilog implementation details, see [pipeline.md](../internal/pipeline.md).

## Credit-based Pipeline Stages

As shown below, Assassyn generates architectures with credit-based architecture pipeline
stages. When the architecture has a pending activation, it gains a credit. Once it is
successfully activated, it consumes the credit. The architecture accepts data from the
FIFOs from prior stages.

````
    +-------+
--->|credit |-------+
    +-------+       |--[O1]->
-[I1]->|    Stage   |--[O2]->
-[I2]->|            |
       +------------+
[A] [B] are stage registers.

````

## Cross-stage Combinational Communication

As shown below, credit-based pipeline stages can also have combinational pins
that connect to downstream modules. Downstream modules can recursively
connect to other downstream modules, or other pipeline stages.

````
    +--------+
    | credit |-------+
    +--------+       |             +--------------+
       |    Stage1   |------------>|              |---> Other modules
       |             |             | Downstream   |
       +-------------+             |              |
                                   +--------------+
    +--------+                          ^
    | credit |-------+                  |
    +--------+       |------------------+
       |    Stage2   |
       |             |
       +-------------+
````

# Execution Model

## Driver Module

The `Driver` is a special module that serves as a pipeline stage. This module functions like the "main" function in software and acts as the "clock" of a Verilog system. The driver is unconditionally activated each cycle to execute its internal logic and drive subsequent stages.

```
+--------+
| Driver |
+--------+
```

## Inter-stage Sequential Communication

Inter-stage sequential communication occurs when the `Driver` activates another stage using an async call.

### Pipeline Stage Micro-Architecture

The figure below illustrates a 2-stage architecture with credit-based flow control.

**Credit-based Flow Control:** The core mechanism for inter-stage communication uses a credit system where each module maintains a credit counter. When the `driver` makes an async call to the `adder`, it **increases the adder's credit counter** to indicate that the `adder` has a pending function call to process. The `driver` has infinite credits as it serves as the "main" function of the system. When the `adder` executes `wait_until`, it **consumes one credit** (decreases its credit counter). This credit-based mechanism is especially useful for designs like CPU decoder stagesâ€”when data is not yet valid, the decode call is not cleared to decode again in the next cycle. Each cycle, the `adder` checks its credit counter to determine whether this module should be activated.

**Stage FIFO:** The `Driver` feeds data to the `adder` by writing to the stage register. To maintain architectural generality, we use a FIFO template as an over-engineered stage register.

**Async Call:** The key insight is that a module activates a downstream module like an async function call. By "async," we mean the callee does not take effect immediately because register writes are not available until the next cycle, which aligns perfectly with the concept of async calls. The credit system ensures proper flow control: **async calls increase credits**, **wait_until consumes credits**, and the **driver has infinite credits** as the system's main controller.

```
              +-------+
     |------->|credit |-------+
+--------+    +-------+       |
| Driver |--[A]->|    Adder   |
|        |--[B]->|            |
+--------+       +------------+

[A] [B] are stage registers.
```

## Inter-stage Combinational Communication

Cross-module same-cycle communications are implemented through combinational connections.

```
                   +---+
     +------------>|   |
     |             |cnt|-----+
+--------+         +---+     |       +------+
| Driver |--[data]->|  lhs   |------>|      |
|        |          +--------+       |      |
|        |          +--------+       | add  |
|        |--[data]->|  rhs   |------>|      |
+--------+         +---+     |       +------+
     |             |cnt|-----+
     +------------>|   |
                   +---+

[data] represents stage registers.
```

The `Driver` diverges by pushing data to `lhs` and `rhs` through the stage buffer, and then they both converge to the `add` module combinationally. Data from `lhs` and `rhs` arrives at `add` in the same cycle.

## Topological Order across Downstreams

Since downstream modules are purely combinational logic, they assume that all operations have no cyclic dependencies. Additionally, downstream modules can recursively be downstream modules of other downstream modules. During code generation, we need to establish a topological order across these modules to guarantee correct execution order.

## Register Arrays

Register arrays support multiple concurrent access patterns:

```
Port1     +--------+
--we----->|        |---reader1-->
--wdata-->|  Array |
--widx--->|        |
          +--------+
           ^ ^    ^
           | |    | Port2
          we widx data
```

**Writes:** Multiple writes to an array are first gathered by ports, and then writes using the same port are one-hot selected for the enable signal `we`, data `wdata`, and index `widx`. The register is written on the positive edge when `we` is enabled.

**Read:** Currently, the entire register array is routed out of the module for reading.
